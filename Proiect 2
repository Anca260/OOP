#include <iostream>

using namespace std;

class Nod
{
protected:
    int info;
    Nod* next;
public:
    Nod();
    Nod(int);
    Nod(int, Nod*);
    Nod(const Nod& nod2);
    virtual ~Nod();

    int getInfo();
    Nod* getNext();
    void setInfo(int);
    void setNext(Nod*);
    Nod& operator =(const Nod&);
    friend istream& operator >>(istream&, Nod&);
    friend ostream& operator <<(ostream&, Nod&);
};

Nod::Nod()
{
    ///this -> info = 0;
    this -> next = NULL;
}
Nod::Nod(int info)
{
    this -> info = info;
    this -> next = NULL;
}
Nod::Nod(int info, Nod* next)
{
    this -> info = info;
    this -> next = next;
}
Nod::Nod(const Nod& n2)
{
    this -> info = n2.info;
    this -> next = n2.next;
}
Nod::~Nod()
{

}
int Nod::getInfo()
{
    return info;
}
Nod* Nod::getNext()
{
    return next;
}
void Nod::setInfo(int info)
{
    this -> info = info;
}
void Nod::setNext(Nod* next)
{
    this -> next = next;
}
Nod& Nod::operator =(const Nod &n)
{
    info = n.info;
    next = n.next;
}
istream& operator >>(istream& in, Nod& n)
{
    in >> n.info;
    return in;
}
ostream& operator <<(ostream& out, Nod& n)
{
    out << n.info;
    return out;
}

///--------------------------------------------------

class Nod_dublu:public Nod
{
private:
    Nod* ante;

public:
    Nod_dublu();
    Nod_dublu(int);
    Nod_dublu(int, Nod*);
    Nod_dublu(int, Nod*, Nod*);
    Nod_dublu(const Nod_dublu& nod2);
    ~Nod_dublu();

    Nod* getAnte();
    void setAnte(Nod*);
    Nod_dublu& operator =(const Nod_dublu&);
    friend istream& operator >>(istream&, Nod_dublu&);
    friend ostream& operator <<(ostream&, Nod_dublu&);
};

Nod_dublu::Nod_dublu()
{
    this -> ante = NULL;
}
Nod_dublu::Nod_dublu(int info):Nod(info)
{
    this -> ante = NULL;
}
Nod_dublu::Nod_dublu(int info, Nod* next):Nod(info, next)
{
    this -> ante = NULL;
}
Nod_dublu::Nod_dublu(int info, Nod* next, Nod* ante):Nod(info, next)
{
    this -> ante = ante;
}
Nod_dublu::Nod_dublu(const Nod_dublu& n2):Nod(n2)
{
    this -> ante = n2.ante;
}
Nod_dublu::~Nod_dublu()
{

}
Nod* Nod_dublu::getAnte()
{
    return ante;
}
void Nod_dublu::setAnte(Nod* ante)
{
    this -> ante = ante;
}
Nod_dublu& Nod_dublu::operator =(const Nod_dublu &n)
{
    Nod::operator=(n);
    ante = n.ante;
}
istream& operator >>(istream& in, Nod_dublu& n)
{
    in >>((Nod&) n);
}
ostream& operator <<(ostream& out, Nod_dublu& n)
{
    out <<((Nod&) n);
}

///----------------------------------------

class Lista
{
protected:
    Nod_dublu* prim;
    Nod_dublu* ultim;

public:
    Lista();
    Lista(int, int*);
    Lista(const Lista&);
    virtual ~Lista();

    void inserare_final(int);
    void inserare_pozitie(int, int, int);
    void stergere_pozitie(int, int);
    virtual void citire(istream &);
    virtual void afisare(ostream &);
    friend istream & operator >> (istream &, Lista &);
    friend ostream & operator << (ostream &, Lista &);
    Lista& operator =(Lista &);
};

Lista::Lista()
{
    prim = NULL;
    ultim = NULL;
}
Lista::Lista(int n, int *v)
{
    prim = NULL;
    ultim = NULL;
    for(int i = 1; i <= n; i++)
        inserare_final(v[i]);
}
Lista::Lista(const Lista& ld)
{
    Nod_dublu* p = ld.prim;
    Nod_dublu* r = prim;
    while(p != ld.ultim)
    {
        prim = ld.prim;
        p = (Nod_dublu*) p -> getNext();
        r = (Nod_dublu*) r -> getNext();
    }
    ultim = ld.ultim;
}
Lista::~Lista()
{
    Nod_dublu* p = prim;
    if(p == ultim)
    {
        delete p;
        return;
    }

    do
    {
        Nod_dublu* aux;
        aux = (Nod_dublu*) p -> getNext();
        delete p;
        p = aux;
    }
    while(p != ultim);

    delete p;
}

void Lista::inserare_final(int info)
{
    if(prim == NULL)
    {
        prim = new Nod_dublu(info);
        ultim = prim;
    }
    else
    {
        Nod_dublu* aux = new Nod_dublu(info);
        ultim -> setNext(aux);
        aux -> setAnte(ultim);
        ultim = aux;
    }
}
void Lista::inserare_pozitie(int poz, int data, int n)
{
    if(poz > n + 1)
    {
        cout << "Valoarea introdusa ca pozitie este incorecta.\n";
        return;
    }

    if(poz == 1) ///inserarea unui element la inceputul listei
    {
        if(prim == NULL)
            prim = new Nod_dublu(data);
        else
        {
            Nod_dublu* aux = new Nod_dublu(data, prim);
            prim = aux;
        }
    }
    else if(poz == n + 1)
        inserare_final(data);
    else
    {
        int cnt = 1;
        Nod_dublu* p = prim;
        while(cnt != poz - 1)
        {
            p = (Nod_dublu*) p -> getNext();
            cnt++;
        }

        Nod_dublu* urm = (Nod_dublu*) p -> getNext();
        Nod_dublu* aux = new Nod_dublu(data, urm, p);
        urm -> setAnte(aux);
        p -> setNext(aux);
    }
}
void Lista::stergere_pozitie(int poz, int n)
{
    if(prim == NULL)
    {
        cout << "Nu se poate efectua stergerea.\n";
        return;
    }
    if(poz > n)
    {
        cout << "Valoarea introdusa ca pozitie este incorecta.\n";
        return;
    }

    if(poz == 1) ///stergerea primului element al listei
    {
        if (prim == ultim)
        {
            delete prim;
            prim = NULL;
            ultim = NULL;
        }
        else
        {
            Nod_dublu* aux;
            aux = (Nod_dublu*) prim -> getNext();
            prim = aux;
            prim -> setAnte(NULL);
        }
    }
    else if(poz == n) ///stergerea ultimului element al listei
    {
        Nod_dublu* pred;
        pred = (Nod_dublu*)ultim -> getAnte();
        delete ultim;
        ultim = pred;
        ultim -> setNext(NULL);
    }
    else ///stergerea unui element din interiorul listei
    {
        int cnt = 1;
        Nod_dublu* p = prim;
        while(cnt != poz)
        {
            p = (Nod_dublu*) p -> getNext();
            cnt++;
        }

        Nod_dublu* pred;
        pred = (Nod_dublu*) p -> getAnte();
        Nod_dublu* succ;
        succ = (Nod_dublu*) p -> getNext();

        pred -> setNext(succ);
        succ -> setAnte(pred);
        delete p;
    }
}
void Lista::citire(istream& in)
{
    int val;
    in >> val;
    inserare_final(val);
}
void Lista::afisare(ostream& out)
{
    Nod_dublu* p = prim;
    if(prim == NULL)
    {
        out << "Lista vida\n";
        return;
    }
    while(p != ultim)
    {
        out << p -> getInfo() << " ";
        out << p -> getAnte() << " ";
        out << p -> getNext() << " \n";
        p = (Nod_dublu*) p -> getNext();
    }
    out << p -> getInfo() << " ";
    out << p -> getAnte() << " ";
    out << p -> getNext() << " \n";
}
istream & operator >> (istream &in, Lista &lc)
{
    lc.citire(in);
    return in;
}
ostream & operator << (ostream &out, Lista &lc)
{
    lc.afisare(out);
    return out;
}
Lista& Lista::operator =(Lista &ld)
{
    cout << "asig lista";
    Nod_dublu* p = prim;

    while(p != NULL)
    {

        p = (Nod_dublu*) p -> getNext();
    }


}

///-------------------------------------------

class Lista_Circulara:public Lista
{
private:
    // Lista ld;
public:
    Lista_Circulara();
    Lista_Circulara(int, int*);
    Lista_Circulara(const Lista_Circulara&);
    ~Lista_Circulara();

    void inserare_final(int);
    void inserare_pozitie(int, int, int);
    void stergere_pozitie(int, int);
    void citire(istream&);
    void afisare(ostream&);
    friend istream & operator >> (istream &, Lista_Circulara &);
    friend ostream & operator << (ostream &, Lista_Circulara &);
    int josephus(int, int);
};

Lista_Circulara::Lista_Circulara():Lista() {};
Lista_Circulara::Lista_Circulara(int n, int* v):Lista(n, v)
{
    ultim -> setNext(prim);
    prim -> setAnte(ultim);
}
Lista_Circulara::Lista_Circulara(const Lista_Circulara& lc):Lista(lc)
{
    ultim -> setNext(prim);
    prim -> setAnte(ultim);
}
Lista_Circulara::~Lista_Circulara() {};
void Lista_Circulara::inserare_final(int info)
{
    Lista::inserare_final(info);
    ultim -> setNext(prim);
    prim -> setAnte(ultim);
}
void Lista_Circulara::inserare_pozitie(int poz, int data, int n)
{
    Lista::inserare_pozitie(poz, data, n);
    ultim -> setNext(prim);
    prim -> setAnte(ultim);
}
void Lista_Circulara::stergere_pozitie(int poz, int n)
{
    Lista::stergere_pozitie(poz, n);
    if(poz == 1 && prim != NULL)
    {
        ultim -> setNext(prim);
        prim -> setAnte(ultim);
    }
    else if(poz == n)
    {
        ultim -> setNext(prim);
        prim -> setAnte(ultim);
    }
}
void Lista_Circulara::citire(istream& in)
{
    Lista::citire(in);
    ultim -> setNext(prim);
    prim -> setAnte(ultim);
}
void Lista_Circulara::afisare(ostream& out)
{
    Lista::afisare(out);
    if(prim != NULL)
    {
        ultim -> setNext(prim);
        prim -> setAnte(ultim);
        cout << prim -> getInfo() << " ";
        cout << prim -> getAnte() << " ";
        cout << prim -> getNext() << " \n";
    }
}
istream & operator >> (istream &in, Lista_Circulara &lc)
{
    lc.citire(in);
    return in;
}
ostream & operator << (ostream &out, Lista_Circulara &lc)
{
    lc.afisare(out);
    return out;
};
int Lista_Circulara::josephus(int k, int n)
{
    ///!! copiere lista
    int cnt = 0, poz = 0, nr = n;
    if(nr == 0)
    {
        cout << "Nu se poate efectua operatia.\n";
        return 0;
    }

    Nod_dublu* aux = prim;
    while(nr != 0)
    {
        cnt++;
        if(aux == prim)
            poz = 0;

        poz = poz + 1;
        if(cnt == k)
        {
            cnt = 0;
            if(nr == 1)
                cout << aux -> getInfo();
            stergere_pozitie(poz, nr);
            aux =(Nod_dublu*) aux -> getNext();
            nr--;
            poz--;
        }
        else if(cnt != k && prim != ultim)
            aux = (Nod_dublu*) aux -> getNext();
    }
}

int main()
{
    /* Nod_dublu* n = new Nod_dublu(2);
     cout << *n;
     cout << "\n";
     Nod_dublu* n1 = new Nod_dublu();
     cin >> *n1;
     cout << *n1;*/



 /*   Lista_Circulara* lc = new Lista_Circulara();
    for(int i = 1; i <= 0; i++)
        cin >> *lc;
    cout << *lc;
    lc.josephus(3, 3);*/


    /* Nod_dublu* n = new Nod_dublu(3);
     Nod_dublu* n1 = new Nod_dublu(4);
     *n = *n1;
     cout << *n;
     */


    /*  cout << "\n\n";
      Lista_Circulara* lc3(lc);
      lc3 -> afisare();

      delete lc;

      //    lc->inserare_sfarsit(2);*/
    /*Lista_Circulara lc;
    for(int i = 1; i <= 3; i++)
        cin >> lc;
    cout << lc;*/

    // Nod* n1 = new Nod(2);
    //Nod* n2 = new Nod(*n1);
    // Nod n2(*n1);

    //Nod n(2);
    /*Nod n(2);
    Nod* n1;
     n = *n1;*/

     int i;
     Lista ld1;
     for(i = 1; i <= 2; i++)
         cin >> ld1;

     Lista ld2;
     for(i = 1; i <= 2; i++)
         cin >> ld2;

     cout << ld1;
     cout << "\n\n";
     cout << ld2;
     cout << "\n\n";

     ld1 = ld2;
     cout << "\n\n";
     cout << ld1;

    return 0;
}
