#include <iostream>

using namespace std;

class Nod
{
protected:
    int info;
    Nod* next;
public:
    Nod();
    Nod(int);
    Nod(int, Nod*);
    Nod(const Nod& nod2);
    virtual ~Nod();

    int getInfo();
    Nod* getNext();
    void setInfo(int);
    void setNext(Nod*);
    void citire(istream &in);
    void afisare(ostream &out);
//    friend istream& operator >>(istream& in, Nod n){n -> citire(in); return in;};
  //  friend istream& operator <<(ostream&, Nod){n -> afisare(out); return out;};
};

Nod::Nod()
{
    ///this -> info = 0;
    this -> next = NULL;
}
Nod::Nod(int info)
{
    this -> info = info;
    this -> next = NULL;
}
Nod::Nod(int info, Nod* next)
{
    this -> info = info;
    this -> next = next;
}
Nod::Nod(const Nod& n2)
{
    //info = n2.info;
    //next = n2.next;
    //info = n2 -> getInfo();
    cout<<"Copy constructor called "<<endl;
}
Nod::~Nod()
{

}
int Nod::getInfo()
{
    return info;
}
Nod* Nod::getNext()
{
    return next;
}
void Nod::setInfo(int info)
{
    this -> info = info;
}
void Nod::setNext(Nod* next)
{
    this -> next = next;
}
void Nod::citire(istream &in)
{
    int val;
    in >> val;
    info = val;
    next = NULL;
}
void Nod::afisare(ostream &out)
{
    out << info;
}/*
friend istream& operator >>(istream& in, Nod& n)
{
    n.citire(in);
    return in;
}
friend istream& operator <<(ostream& out, Nod& n)
{
    n.afisare(out);
    return out;
}*/


class Nod_dublu:public Nod
{
private:
    Nod* ante;

public:
    Nod_dublu();
    Nod_dublu(int);
    Nod_dublu(int, Nod*);
    Nod_dublu(int, Nod*, Nod*);
    ~Nod_dublu();

    Nod* getAnte();
    void setAnte(Nod*);
};

Nod_dublu::Nod_dublu()
{
    this -> ante = NULL;
}
Nod_dublu::Nod_dublu(int info):Nod(info)
{
    this -> ante = NULL;
}
Nod_dublu::Nod_dublu(int info, Nod* next):Nod(info, next)
{
    this -> ante = NULL;
}
Nod_dublu::Nod_dublu(int info, Nod* next, Nod* ante):Nod(info, next)
{
    this -> ante = ante;
}
Nod_dublu::~Nod_dublu()
{

}
Nod* Nod_dublu::getAnte()
{
    return ante;
}
void Nod_dublu::setAnte(Nod* ante)
{
    this -> ante = ante;
}


class Lista
{
protected:
    Nod_dublu* prim;
    Nod_dublu* ultim;

public:
    Lista();
    Lista(int, int*);
    Lista(const Lista&);
    virtual ~Lista();

    void inserare_final(int);
    void inserare_pozitie(int, int, int);
    void stergere_pozitie(int, int);
    void citire(istream &);
    friend istream & operator >> (istream &in, Lista &ld){ ld.citire(in); return in;};
    void afisare();
};

Lista::Lista()
{
    prim = NULL;
    ultim = NULL;
}
Lista::Lista(int n, int *v)
{
    prim = NULL;
    ultim = NULL;
    for(int i = 1; i <= n; i++)
        inserare_final(v[i]);
}
Lista::Lista(const Lista& ld)
{
    Nod_dublu* p = ld.prim;
    Nod_dublu* r = prim;
    while(p != ld.ultim)
    {
        prim = ld.prim;
        p = (Nod_dublu*) p -> getNext();
        r = (Nod_dublu*) r -> getNext();
    }
    ultim = ld.ultim;
}
Lista::~Lista()
{
    Nod_dublu* p = prim;
    if(p == ultim)
    {
        delete p;
        return;
    }

    do
    {
        Nod_dublu* aux;
        aux = (Nod_dublu*) p -> getNext();
        delete p;
        p = aux;
    }
    while(p != ultim);

    delete p;
}

void Lista::inserare_final(int info)
{
    if(prim == NULL)
    {
        prim = new Nod_dublu(info);
        ultim = prim;
    }
    else
    {
        Nod_dublu* aux = new Nod_dublu(info);
        ultim -> setNext(aux);
        aux -> setAnte(ultim);
        ultim = aux;
    }
}
void Lista::inserare_pozitie(int poz, int data, int n)
{
    if(poz > n + 1)
    {
        cout << "Valoarea introdusa ca pozitie este incorecta.\n";
        return;
    }

    if(poz == 1) ///inserarea unui element la inceputul listei
    {
        if(prim == NULL)
            prim = new Nod_dublu(data);
        else
        {
            Nod_dublu* aux = new Nod_dublu(data, prim);
            prim = aux;
        }
    }
    else if(poz == n + 1)
        inserare_final(data);
    else
    {
        int cnt = 1;
        Nod_dublu* p = prim;
        while(cnt != poz - 1)
        {
            p = (Nod_dublu*) p -> getNext();
            cnt++;
        }

        Nod_dublu* urm = (Nod_dublu*) p -> getNext();
        Nod_dublu* aux = new Nod_dublu(data, urm, p);
        urm -> setAnte(aux);
        p -> setNext(aux);
    }
}
void Lista::stergere_pozitie(int poz, int n)
{
    if(prim == NULL)
    {
        cout << "Nu se poate efectua stergerea.\n";
        return;
    }
    if(poz > n)
    {
        cout << "Valoarea introdusa ca pozitie este incorecta.\n";
        return;
    }

    if(poz == 1) ///stergerea primului element al listei
    {
        if (prim == ultim)
        {
            delete prim;
            prim = NULL;
            ultim = NULL;
        }
        else
        {
            Nod_dublu* aux;
            aux = (Nod_dublu*) prim -> getNext();
            prim = aux;
            prim -> setAnte(NULL);
        }
    }
    else if(poz == n) ///stergerea ultimului element al listei
    {
        Nod_dublu* pred;
        pred = (Nod_dublu*)ultim -> getAnte();
        delete ultim;
        ultim = pred;
        ultim -> setNext(NULL);
    }
    else ///stergerea unui element din interiorul listei
    {
        int cnt = 1;
        Nod_dublu* p = prim;
        while(cnt != poz)
        {
            p = (Nod_dublu*) p -> getNext();
            cnt++;
        }

        Nod_dublu* pred;
        pred = (Nod_dublu*) p -> getAnte();
        Nod_dublu* succ;
        succ = (Nod_dublu*) p -> getNext();

        pred -> setNext(succ);
        succ -> setAnte(pred);
        delete p;
    }
}
void Lista::citire(istream& in)
{
    int val;
    in >> val;
    inserare_final(val);
}
void Lista::afisare()
{
    Nod_dublu* p = prim;
    while(p != ultim)
    {
        cout << p -> getInfo() << " ";
        cout << p -> getAnte() << " ";
        cout << p -> getNext() << " \n";
        p = (Nod_dublu*) p -> getNext();
    }
    cout << p -> getInfo() << " ";
    cout << p -> getAnte() << " ";
    cout << p -> getNext() << " \n";
}

class Lista_Circulara:public Lista
{
private:
    // Lista ld;
public:
    Lista_Circulara();
    Lista_Circulara(int, int*);
    Lista_Circulara(const Lista_Circulara&);
    ~Lista_Circulara();

    void inserare_final(int);
    void inserare_pozitie(int, int, int);
    void stergere_pozitie(int, int);
    void afisare();
    int josephus(int, int);
};

Lista_Circulara::Lista_Circulara():Lista() {};
Lista_Circulara::Lista_Circulara(int n, int* v):Lista(n, v)
{
    ultim -> setNext(prim);
    prim -> setAnte(ultim);
}
Lista_Circulara::Lista_Circulara(const Lista_Circulara& lc):Lista(lc)
{
    ultim -> setNext(prim);
    prim -> setAnte(ultim);
}
Lista_Circulara::~Lista_Circulara() {};
void Lista_Circulara::inserare_final(int info)
{
    Lista::inserare_final(info);
    ultim -> setNext(prim);
    prim -> setAnte(ultim);
}
void Lista_Circulara::inserare_pozitie(int poz, int data, int n)
{
    Lista::inserare_pozitie(poz, data, n);
    ultim -> setNext(prim);
    prim -> setAnte(ultim);
}
void Lista_Circulara::stergere_pozitie(int poz, int n)
{
    Lista::stergere_pozitie(poz, n);
    if(poz == 1 && prim != NULL)
    {
        ultim -> setNext(prim);
        prim -> setAnte(ultim);
    }
    else if(poz == n)
    {
        ultim -> setNext(prim);
        prim -> setAnte(ultim);
    }
}
void Lista_Circulara::afisare()
{
    Lista::afisare();
    cout << prim -> getInfo() << " ";
    cout << prim -> getAnte() << " ";
    cout << prim -> getNext() << " \n";
}
int Lista_Circulara::josephus(int k, int n)
{
    ///!! copiere lista
    int cnt = 0, poz = 0, nr = n;

    Nod_dublu* aux = prim;
    if(prim == NULL)
    {
        cout << "Nu se poate efectua operatia.\n";
        return 0;
    }

    while(nr != 0)
    {
        cnt++;
        if(aux == prim)
            poz = 0;

        poz = poz + 1;
        if(cnt == k)
        {
            cnt = 0;
            cout << aux -> getInfo();
            Nod_dublu* pred = (Nod_dublu*) aux -> getAnte();
            Nod_dublu* succ = (Nod_dublu*) aux -> getAnte();
            pred -> setNext(succ);
            succ -> setAnte(pred);
            if(aux == ultim)
                ultim = pred;
            else if(aux == prim)
                prim = succ;
            delete aux;
            aux =(Nod_dublu*) aux -> getNext();
            nr--;
            poz--;
        }
        else if(cnt != k && prim != ultim)
            aux = (Nod_dublu*) aux -> getNext();
    }
}

int main()
{
    /*Lista_Circulara* lc = new Lista_Circulara();
    lc->inserare_final(2);
    lc->inserare_final(4);
    lc->inserare_pozitie(2, 3, 2);
    lc->inserare_pozitie(4, 5, 3);
    lc->inserare_pozitie(1, 1, 4);
    lc->afisare();
    // lc->josephus(2, 5);
    cout << "\n\n";
    Lista_Circulara* lc3(lc);
    lc3 -> afisare();

    delete lc;

    //    lc->inserare_sfarsit(2);*/
    Lista* ld = new Lista();
    int val1 = 1, val2 = 2;
    ld >> val1;

    return 0;
}
